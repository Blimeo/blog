---
layout: post
title:  "Machine Learning Crash Course: Part 3"
date:   2017-1-17
author: Daniel Geng and Shannon Shih
comments: true
published: true
description: The third post in our intro to ML tutorial series! Learn all about neural networks!
---

Neural networks are perhaps one of the most exciting recent developments in machine learning. Got a problem? Just throw a neural net at it. Want to make a self-driving car? Throw a neural net at it. Want to [fly a helicopter](http://hackaday.com/2014/04/22/self-learning-helicopter-uses-neural-network/)? Throw a neural net at it. Curious about the [digestive cycles of your sheep?](http://dl.acm.org/citation.cfm?id=901401)? Heck, throw a neural net at it. This extremely powerful algorithm holds much promise (but can also be a bit overhyped). In this article we’ll go through how a neural network actually works, and we’ll discuss some of the limitations of these seemingly magical tools.

## The Biology

The biological brain is perhaps the most powerful computer that we know of. Compared to our the complex organ, even our most powerful supercomputers are a joke. In 2014, Japanese researchers used a [supercomputer to simulate just one second of human brain activity](http://www.telegraph.co.uk/technology/10567942/Supercomputer-models-one-second-of-human-brain-activity.html). It took [40 minutes and 9.9 million watts](http://systems.closeupengineering.it/en/k-computer-fraction-of-the-human-brain/113/). As for the real thing? The little ball of grey matter in our skulls takes barely 20 watts to run, which translates to roughly one [McChicken](http://www.myfitnesspal.com/food/calories/mcdonalds-mcchicken-biscuit-61698140) a day. 

Neglecting **a lot** of details, biological neurons are cells that send and receive electrical impulses from other neurons that they are connected to. A neuron will only fire an electrical impulse when it receives impulses from other neurons that together are stronger than a certain threshold. Anything lower than that threshold and the neuron won’t do anything. Just what that threshold is is dependent on the chemical properties of the neuron in question and varies from neuron to neuron. Upon firing, an electrical impulse shoots out of the neuron and into more neurons downstream and the process continues. In the brain, billions of these interconnected neurons communicating with each other form the basis for consciousness, thought, and McChicken cravings.

## The History

In the mid 1900’s, a [couple of researchers](https://en.wikipedia.org/wiki/Artificial_neuron#History) with particularly smart brains had the idea of creating a “mathematical model” that would be based on how the brain works. They first created a model for a single neuron which imitated a real neuron’s outputs, inputs, and thresholds. The outputs of these single artificial neurons were then fed into even more artificial neurons, creating an entire artificial neural network.

There was just one problem, while researchers had created a model of the human brain they had no way of teaching it anything. The artificial brain could be wired in whatever way researchers wanted, but the vast majority of these wirings didn’t create a brain that had any logical output at all. What was needed was a learning algorithm for their artificial brain.

It was not until the [1980’s](https://en.wikipedia.org/wiki/Backpropagation#History) that such an efficient learning algorithm was used on neural networks. The algorithm was called backpropagation, and finally allowed neural networks to be trained to do amazing things such as speech recognition or autopilots.

## The Model (Overview)

Now that we know the basics of how the brain works and the history of neural networks, let’s look at what a neural network actually does. First off, we’ll think of our neural network as a black box, some machine whose inner workings we don’t really know about yet. We want this machine to take in some set number of numerical inputs (that we can choose) and spit out a set number of numerical outputs (that we can also choose). 

IMAGE OF BLACK BOX
caption: A neural network takes in some inputs, math happens, and some number of outputs pop out.

For example, if we want to classify images (say apples and oranges) then we’d want the number of inputs to be the number of pixels in our images, and the number of outputs to be the number of categories we have (two for the case of apples and oranges). If we were trying to model housing prices then the number of inputs would be the number of features we have, such as location, number of bathrooms, and square footage, and the number of outputs would be just one, for the price of the house.

Our machine has inputs and outputs, but how do we control what inputs create what outputs? That is, how do we change the neural network so certain inputs (say an image of an apple) give the correct outputs (say a 0 for the probability of being an orange and a 1 for the probability of being an apple)? Well, we can add “knobs” to our machine to control the output for a given input. In machine learning lingo, these “knobs” are called the parameters of a neural network. If we tune these knobs to the correct place, then for any input we can get the output that we want.

Going back to our apples and oranges example, if we give our machine an image of an apple but it tells us it thinks it’s an orange then we can go ahead and adjust the knobs of our machine (in other words tune the parameters) until the machine tells us it sees an apple. In essence, this is what it means to train a neural network and this is exactly what the backpropagation algorithm helps do.

## The Model (Details)

Now that we know what a neural network should do and roughly how we can get it to learn, let’s peer inside the black box and talk about what is happening inside the network. To start, we'll discuss what happens inside a single artificial neuron and build it up from there.

For those who have read our post on perceptrons [[[[[ LINK TO POST!!!! ]]]]], this will be very familiar material. That’s because a neuron in a neural network is basically a perceptron on steroids. Similarly to a perceptron, a neuron takes in any number of numerical inputs and has just one output. To get to this output, the neuron calculates an intermediate value called \( s \) by multiplying each input by a different weight, adding them all together, and adding an additional number called the bias. In math: \( s = weight_{1}\times input_{1}+...+weight_{n}\times input_{n}+bias \)

IMAGE OF NERUON CALCULATIOn

Now each neuron could simply output \( s \), but that would be a bit boring as \( s \) is just a linear function, which makes it rather inflexible for modeling real-world data. What we want to do instead is to add one more step, called an activation function. An activation function is any function that takes in our \( s \) and gives the output of our neuron, called the **activation**. The perceptron that we described in the last post gave definitive yes/no answers using a blocky step function as its activation function.

IMAGE OF HEAVESIDE ACTIVATION FUNCTION WITH ANT ON VERY LEFT/RIGHT
Caption: For the step function, there is no way to tell how close you are to a “yes” or a “no”

However, using a step function makes training very difficult because there's no way to tell whether the neural network is getting closer or farther from the correct answer. As an analogy, imagine you are an ant that can only see things very close to you. You are on the lower part of the step function trying to get to the higher part of the step function. But because everything is so flat, you wouldn’t know how far away the “step” part of the step function is, or even in which direction it is (the step function can be mirrored, with a value of 1 on the left and 0 on the right). It’s more or less because of this that makes the step function a bad activation function for training.

To make it easier to train a network, we’ll use a function that is smooth (in other words, a differentiable function). In particular, we’ll use the sigmoid function, which looks something like this:

IMAGE SIGMOID ACTIVATION FUNCTION WITH ANT KNOWING WHICH DIRECTION TO GO
Caption: A sigmoid function is a nice activation function because it is smooth everywhere, making it easier to figure out if you're getting closer to the top

Going back to our ant analogy, an ant could figure out exactly which direction to go and how far to go just by checking in which direction and how much the graph slopes at its current location. Despite the fact that the ant can’t see the high part of the sigmoid function, it can tell in which direction it is and roughly how far away it is.

## Linking it all together

We wouldn't have much of a network if we just had one neuron, would we? The secret to a neural network's ability to make complex decisions lies in its internal structure of interconnected neurons. Just like how neurons in the brain are connected to each other, the output of one neuron becomes the input of another neuron, allowing the neurons to work together to come up with the correct answer.

IMAGE OF NEURON FEEDING ANOTHER NEURON (ALREADY EXISTS, LOOKS SEX C AF)

Of course, we can't just randomly connect neurons to each other and expect everything to work perfectly. The design of a neural network is based on the way our brains process data by structuring neurons into groups of computational “units.” For example, the human visual cortex consists of 5 distinct sections called [V1, V2, V3, V4, and V5](https://en.wikipedia.org/wiki/Visual_cortex). Visual stimuli travels from the retina to V1 where low-level details such as edges and colors are picked out. The information generated by V1 then travels to V2, and then V3 and so on, with each cortex processing progressively more and more complicated information.

IMAGE OF NEURAL NETWORK WITH LAYERS (ANN DIAGRAM)

In a similar way, artificial neural network are composed of layers of artificial neurons. In general, there are three types of layers: an input layer, hidden layers, and an output layer. The input layer (on the very left) will take on values of whatever the input is to the the neural network. Notice that we can have our network take any number of inputs by changing the number of neurons in the input layer. Neat! 

Similarly, the output of the output layer (on the very right) will be the output of the whole neural network, and we can change the number of neurons in the output layer to match the number of outputs we want from our network.

Between the input layer and the output layer are hidden layers. The optimal number of hidden layers is the subject of much discussion, but the short answer is that it's completely up to whoever builds the network. For simplicity, we’ll talk about a network with one hidden layer.

Finally, each layer is fully connected to the one before it and after it. This means the output of a single neuron in a layer connects to (or is the input of) every neuron in the next layer, because the information that a neuron provides in one layer could be useful to any neuron in the next layer. Between each connection is a weight that the output is weighted by. Let’s go through a visual example a simple example (use 1-2-1 net)

D3JS EXAMPLE!!!

## How a Neural Network “Works”

DOGE!!! (ALREADY GOT IT)

Say you're trying to recognize Doge. Do the pink spots (flowers) in the background matter when trying to identify the main object in the picture? Probably not, so that information can probably be discarded. 

So what information is relevant? Well, the object has lines of dark and white pixels that indicate fur, ovals that indicate eyes, triangular things that are probably ears, and a big dark triangle-oval patch that seems to be a nose. 

Many people will probably immediately recognize the object as a dog, but what gives it away? Fur, eyes, ears, and nose are all indications, but they must be considered together in order to figure out that the object is a dog. 
We can visualize this thought process with various neurons tasked with identifying increasingly abstract objects in the image:

LABELED NETWORK PICTURE (ALREADY EXISTS)
How someone might identify a dog. Important inputs that are given a lot of weight are highlighted in red.


Notice how the neurons are organized into layers, where the further right the neurons are, the more abstract the input? Trained neural networks function in a very similar way, although they arrive at this conclusion after training with a lot of data. No one explicitly tells the network to identify dogs in the fashion described above. In fact, most of the time it'll accomplish the same thing with a different method that may not make sense to a human. The above example just provides a rough, slightly inaccurate but conceptual understanding of what's really happening under the hood to make the reasons behind the design of a neural network more clear. You can see some examples of what neurons "actually" see [here](http://playground.tensorflow.org). It takes raw data and refines it with math until it has the answer that it needs.

## Training

Okay, we’ve put it off for long enough! Let’s talk about the real meat of machine learning. The training! 

At its very core, training a neural network just means adjusting the parameters (i.e., the weights and biases) until our network outputs the correct answer (or at least something sufficiently close to it). Precisely how to adjust the parameters for each neuron in the network is one of the reasons why machine learning is such a complicated field of study. We've already covered the general strategy for adjusting the parameters in the Regression section of our [first tutorial](https://ml.berkeley.edu/blog/2016/11/06/tutorial-1/) and you can read about it there, but the gist of it is that you need to specify a cost function that quantifies how "wrong" your neural network is by outputting large values for very wrong answers and small values for more correct answers. 

For example, if we feed some random neural network an image of an apple and it tells us it sees an orange, then the cost for that particular example would be high. The term “cost” comes from the fact that you can think of a neural network with a high cost (and therefore many wrong answers) as bad, or expensive, and vice versa. To ensure that a neural network getting a correct answer isn’t just some fluke, networks are typically trained on thousands upon thousands of training examples. Once we have a cost function and many training examples, we can then perform gradient descent to minimize the cost function by adjusting our parameters.

GRADIENT DESCENT IMAGE (CONVEX FUNCTION WITH LINES, LIKE FIRST POST)

To review, gradient descent is a way to find the minimum of a function. In the case of a neural network, the function that we want to minimize is the cost function. Gradient descent does this by adjusting the parameters of the network such that we get a lower cost function than before. In a sense, gradient descent "moves" downhill whenever possible like an ant feeling out the slope of the terrain. And each time it moves downhill, the gradient descent "saves" its progress by updating the weights and biases in each neuron. Eventually, gradient descent will have found the very bottom of the cost function.

## Backpropagation

Of course, gradient descent needs to know which direction is “downhill” in order to work. Using our ant analogy, an ant sitting on the cost function knows which to go only because of the slope of the cost function. Remember, it can’t see very far, and certainly not far enough to see where the minimum actually is. The ant’s best bet is to go the direction that is sloping downhill the most.

COUNTOUR PLOT OF COST FUNCTION, SHOWING DIFF BETWEEN GD AND OMNISCIENCE

In math terms, these slopes are derivatives. Now if suddenly felt a panic attack settling in upon reading the word “derivative” (or if you have absolutely no idea what a derivative is) don’t worry. This whole section is completely understandable through intuition and third grade math. On the other hand, if you suddenly felt a rush of exhilaration we encourage you to go tackle the collapsible sections at the end of this article where we derive the backpropagation formulas.

The whole point of backpropagation is to find these slopes to help gradient descent work. There is in fact a different slope we need for each of our parameters. That is, going back to our machine analogy, you can imagine yourself turning the knob for single parameter and watching the cost function go up or down. The slope for a particular parameter will tell you which way to turn the knob to make the cost function go down. Once we find out which way to turn each of the knobs (in other words, once we have the derivative of the cost with respect to each of the parameters, both weights and biases) we can turn each of the knobs in the correct direction a tiny bit. We should only turn each of the knobs a tiny bit because turning one knob might affect other knobs’ slopes.

GRAPH VARYING ONE PARAMETER AGAINST COST, ALSO MAYBE HAVE DIAGRAM OF TURNING JUST ONE KNOB ON THE BLACK BOX 

Now as it turns out, a cost function is related most directly to what the outputs of a neural network are. So it should make sense that the slopes of parameters associated with the output layer are easiest to calculate while slopes of parameters associated with the input layer are hardest to calculate. The output layer is closest to the cost function after all. 

Moreover, it turns out that once we calculate the slopes of a given layer, we can easily find the slopes of a previous layer. Intuitively, this makes sense because changing the parameters in one layer will affect the next layer which will affect the next layer, and so on until the cost function itself is affected. Therefore we need to know how all future layers will affect the cost function before we know how a specific layer will affect the cost function.

Thus, we easily calculate the slopes of the last layer, and then the second to last layer, and end up working backwards until we reach the first, input layer. This is why the algorithm to find slopes is called “backpropagation.” We calculate slopes by starting from the back and propagating our algorithm backwards through the neural network until we get all the slopes for gradient descent.

IMAGE OF HOW BACKPROPAGATION ACTUALLY BACK PROPAGATES

That, in a nutshell, is the backpropagation algorithm—the very reason cars can drives themselves, Siri can recognize your voice, and computers can read your checks. Don’t worry if you don’t understand everything immediately. For most people it takes more than a few read-throughs to fully understand what is happening. For those of you who feel affronted that the math has been skipped over, feel free to check out the next two sections. The first is an introduction to notation we’re using and a way to describe neural networks in an elegant way using matrices. The first section is also pretty much required reading before reading the second, which is a derivation of the rules of backpropagation. Cheers!

{% capture matrixmath %}
To use gradient descent we need to find the derivatives of the cost function with respect to each of the parameters. In order to do this, let’s formalize our picture of a neural network in the language of matrices and vectors. In particular, our goals is to write down the **feedforward step**, that is, turning one layer’s outputs into the next layer’s outputs.

Why matrices and vectors though? Why go through all the trouble? Well, in a sense, matrices and vectors give us a “global” view of what is happening in a neural network. That’s because whole layers can be represented by vectors, and operations on layers (such as applying weights and summing) can be represented with matrices. This global view of looking at all the neurons in a layer at once, as opposed to a “local” view looking at only the individual neurons in each layer, allows us to write equations in a very concise, and arguably elegant manner.


Let’s begin by writing our inputs as a column vector, called \( a^1 \). So if we have \( n \) inputs, then our input vector would essentially be a \( 1 \times n \) dimensional matrix. Something like this:

$$ a^1 = \begin{bmatrix} i_1 \\ i_2 \\ \vdots \\ i_n \end{bmatrix} $$

Now be careful. The superscript \( 1 \) is not an exponent (if it were it be quite redundant). Rather it is used to indicate that the vector is associated with the first layer of our network, in other words, the input layer. We choose the letter \( a \) because we can think of the inputs as being the activations (aka the outputs) of the first layer of neurons. You may have already guessed, but we’re going to be calling the vector of activations for the \( l^{th} \) layer \( a^l \). And if we have \( L \) layers, then \( a^L \) (that is, the activations of the very last layer, the output layer) will be the output of our entire neural network. Every \( a^l \) will have a different dimension depending on how many neurons are in each layer.

PIC 1

Now let’s figure out how to write the weights in matrix notation. Of course, we could just throw all the weights into some matrix and call it a day, but let’s be a bit more clever about it. In particular, let’s take advantage of matrix multiplication. We’ll define a \( N \times 1 \) dimensional matrix to be the weights matrix from a previous layer to **a single neuron** in the next layer, where \( N \) would be the number of neurons in the **previous** layer (all of this seemingly arbitrary notation will pay off in the end, we promise). Let’s call this matrix \( w^l_k \) for the \( k^{th} \) neuron in the \( l^{th} \) layer.

PIC 2

Notice now that for the \( k^{th} \) neuron in the \( l^{th} \) layer, we can get its weighted sum of its inputs, called \( z^l_k \) (where \( l \) is the layer and \( k \) is the \( k^{th} \) neuron) by simply taking the [dot product](http://mathinsight.org/dot_product_matrix_notation) between \( a^{l-1} \) and \( w^l_k \).

PIC 3

What’s more, we can actually write out a weight matrix for each layer, where each row in the matrix is a \( w^l_k \). Call this matrix \( w^l \):

$$ w^l = \begin{bmatrix} \cdots w^l_1 \cdots \\ \cdots w^l_2 \cdots \\ \vdots \\ \cdots w^l_n \cdots \end{bmatrix} $$

Notice that this takes advantage of the [definition](https://www.mathsisfun.com/algebra/matrix-multiplying.html) of matrix multiplication in that \( w^la^{l-1} \) gives a vector of the weighted inputs for each neuron, which we’ll call \( z^l \).

$$ w^la^{l-1} = \begin{bmatrix} \cdots w^l_1 \cdots \\ \cdots w^l_2 \cdots \\ \vdots \\ \cdots w^l_n \cdots \end{bmatrix} \begin{bmatrix} a^l_1 \\ \vdots \\ a^l_m \end{bmatrix}= \begin{bmatrix} w^l_1 \cdot a^{l-1} \\ w^l_2 \cdot a^{l-1} \\ \vdots \\ w^l_n \cdot a^{l-1} \end{bmatrix} = \begin{bmatrix} z^l_1 \\ z^l_2 \\ \vdots \\ z^l_n \end{bmatrix} = z^l $$ 

(where there’s \( n \) neurons in the \( l^{th} \) layer and \( m \) neurons in the \( (l-1)^{th} \) layer)

Each layer \( l \), with \( n \) neurons, also has a bias vector:

$$ b^l = \begin{bmatrix} b^l_1 \\ b^l_2 \\ \vdots \\ b^l_n \end{bmatrix} $$

We can add this vector to our weighted sums vector, \( z^l \), which should also be \( 1 \times n \) dimensional, to get \( s^l \). \( s^l \) here can be interpreted as the “layer-level” view of the “neuron-level” statement \( s = weight_{1}\times input_{1}+...+weight_{n}\times input_{n}+bias \) from above.

Now that we have \( s^l \), we can apply our activation function to it. Above, we introduced the sigmoid function as our activation function, but in fact any differentiable function can be used as our activation function, granted some are better than others (common ones include ReLU, tanh, and arctan). To account for this, we’ll use \( f \) to represent our activation function.

So to apply \( f \) to our \( s^l \) vector, we simply write \( f(s^l) \), which means applying \( f \) to each of the elements in the \( s^l \) vector.

PIC 6 (show feed forward with matrix operations)

Caption: To do a feedforward step, we first multiply the output of a layer by the weight matrix, add the bias vector, and then apply the activation funciton

{% endcapture %}

{% include collapsible.html content=matrixmath title="Matrix Math"%}

