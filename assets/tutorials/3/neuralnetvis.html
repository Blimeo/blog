<!DOCTYPE html>
<html >
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width">
  
  

    <style>
      /* explanation for @namespace here: http://stackoverflow.com/questions/23034283/is-it-possible-to-use-htmls-queryselector-to-select-by-xlink-attribute-in-an */
      @namespace xlink "http://www.w3.org/1999/xlink";
      circle.node:hover {
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.2);
        transition: all 200ms ease-out;
      }
    </style>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<!--    <script type="text/javascript" src="http://code.interactjs.io/v1.2.6/interact.min.js"></script>-->
  
  
  
  <script type="text/javascript">
if (!document.registerElement) {
	document.writeln(decodeURI('%3Cscript%20src=%22https://cdnjs.cloudflare.com/ajax/libs/webcomponentsjs/0.7.12/webcomponents.min.js%22%20type=%22text/javascript%22%3E%3C/script%3E'));
}
</script>

<script src="knob/index.js" type="text/javascript" async></script>
<link href="knob/style.css" type="text/css" rel="stylesheet">



<style type="text/css" shim-shadowdom>
/* Requires shim-shadowdom and webcomponentsjs in Firefox (due to lack of ::shadow support). https://github.com/Polymer/docs/issues/269 */
#transition x-knob::shadow .knob_gfx { transition: 125ms transform; }
</style>
  
</head>

<body>
  <script> // sizing variables
    var width = 960;
    var height = 500;
    var nodeSize = 25;
    </script>
    <script> // process nodes
      
      // works best if the layer indices start at 1
      data = [
        {"label": "input 1", "layer": 1, bias: 0},
        {"label": "hidden 1", "layer": 2, bias: 0},
        {"label": "hidden 2", "layer": 2, bias: 0},
        {"label": "output 1", "layer": 3, bias: 0}
      ];
      
      // refer to nodes by their labels. 
      // if a weight isn't specified for a connection, default will be 1
      weights = [
        {"startLabel": "input 1", "endLabel": "hidden 1", "weight": 5},
        {"startLabel": "hidden 1", "endLabel": "output 1", "weight": -3},
        {"startLabel": "input 1", "endLabel": "hidden 2", "weight": 2}
      ]
      
      function getStructure(data) {
        var structure = {};
        for(var i = 0; i < data.length; i++) {
          var node = data[i];
          if(node.layer in structure) {
            structure[node.layer] += 1;
          }
          else {
            structure[node.layer] = 1;
          }
        }
        return structure;
      }
      
      // dict containing how many nodes in each layer
      // networkStructure[layer] = # of nodes
      var networkStructure = getStructure(data); 
      
      // creates nodes with labels, layers, and position
      function positionNodes(data, structure) {
        var nodes = []; // contains newly created nodes
        // sets width between layers
        var layerwidth = width / (Object.keys(structure).length + 1);
        // counts number of nodes drawn so far in each layer (inverse of structure)
        var nodeCount = {};
        for(var i = 0; i < data.length; i++) {
          if(data[i].layer in nodeCount) {
            nodeCount[data[i].layer] += 1;
          }
          else {
            nodeCount[data[i].layer] = 1;
          }
          var node = {"label": data[i].label,
                      "layer": data[i].layer,
                      "bias": data[i].bias};
          var x = layerwidth * node.layer;
          var y = nodeCount[node.layer] * height / (structure[node.layer]+1);
          node["x"] = x;
          node["y"] = y;
          nodes.push(node);
        }
        return nodes;
      }
      
      var nodes = positionNodes(data, networkStructure);
    </script>
  
    <script> // draw lines between nodes
      var lines = [];
      for(var start = 0; start < nodes.length; start++) {
        var startNode = nodes[start];
        for(var end = 0; end < nodes.length; end++) {
          var endNode = nodes[end];
          if(endNode.layer === startNode.layer + 1) {
            // find weight for connection from weights array, if any
            
            lineweight = weights.find(function(x) {return x.startLabel === startNode.label
                                                       && x.endLabel === endNode.label;});
            if(lineweight) {
              lineweight = lineweight.weight;
            }
            else {
              lineweight = 1;
            }
              
            lines.push({"x1": startNode.x, 
                        "y1": startNode.y,
                        "x2": endNode.x, 
                        "y2": endNode.y, 
                        "weight": lineweight,
                        // id format: index_of_startNode_in_nodes-index_of_endNode_in_nodes
                        "id": start.toString() + "-" + end.toString()}); 
          }
        }
      }  
    </script>
  
<!--
    <script>
      var startX, startY;
      var selected = null;
      function getCoords(event) {
        startX = event.pageX;
        startY = event.pageY;
        selected = event.target;
      }
      function adjustWeight(event) {
        if(selected !== null && selected.hasAttribute('stroke-width')) {
         var weight = document.getElementById(selected.getAttribute('data-line'));
         strokewidth = weight.getAttribute('stroke-width');

            if(startY > event.pageY && strokewidth < nodeSize) {
              weight.setAttribute('stroke-width', Math.abs(strokewidth+1));
            }
            else if(startY < event.pageY && strokewidth > -nodeSize) {
              weight.setAttribute('stroke-width', Math.abs(strokewidth-1));
            }
    //        document.getElementById(event.target.getAttribute('data-line')).setAttribute('stroke-width', 1); 
          var weightlabel = document.querySelectorAll('[*|href="#' + selected.getAttribute('data-line') + '"]')[0]
          weightlabel.innerHTML = strokewidth;
          weightlabel.parentElement.setAttribute("dy", (-strokewidth-12).toString());
          
        }
      }
      function stopmousedown(event) {
        selected = null;
      }
    </script>
-->
  
    <script>
      var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);
//        .attr("onmousedown", "getCoords(event)")
//        .attr("onmousemove", "adjustWeight(event)")
//        .attr("onmouseup", "stopmousedown(event)");
      
      var line = svg.selectAll("lines")
                    .data(lines).enter()
                    .append("path")
                      .attr("d", function(d) { return "M " + d.x1 + " " + d.y1 + " L " + d.x2 + " " + d.y2;})
                      .attr("stroke", "black")
                      .attr("stroke-width", function(d) { return Math.abs(d.weight); })
                      .attr("id", function(d) {return d.id;});
      // an invisible line that is thicker than the actual line for ease of interaction
      var selectable = svg.selectAll("selectable")
                    .data(lines).enter()
                    .append("path")
                      .attr("d", function(d) { return "M " + d.x1 + " " + d.y1 + " L " + d.x2 + " " + d.y2;})
//                      .attr("stroke", "red")
                      .attr("stroke-width", "20px")
                      .attr("data-line", function(d) {return d.id;})
                      .attr("pointer-events", "visible");
      
      
      var drag = d3.behavior.drag()
          .on("drag", function(d, i) {
            
              var weight = document.getElementById(this.getAttribute('data-line'));
              var weightlabel = document.querySelectorAll('[*|href="#' + this.getAttribute('data-line') + '"]')[0];
              strokewidth = parseInt(document.querySelectorAll('[*|href="#' + this.getAttribute('data-line') + '"]')[0].innerHTML);

              if(d3.event.dy > 0 && strokewidth < nodeSize) {
                strokewidth = strokewidth+1;
                weight.setAttribute('stroke-width', Math.abs(strokewidth));
              }
              else if(d3.event.dy <= 0 && strokewidth > -nodeSize) {
                strokewidth = strokewidth-1;
                weight.setAttribute('stroke-width', Math.abs(strokewidth));
              }
              weightlabel.innerHTML = strokewidth;
              weightlabel.parentElement.setAttribute("dy", (-Math.abs(strokewidth)/2-12).toString());
          
          }
      );
      selectable.call(drag);
      
      var weightlabels = svg.selectAll("weights")
                    .data(lines).enter()
                    .append("text")
                      .attr("style", "text-anchor: middle;")
                      .attr("dy", -12)
      weightlabels.append("textPath")
                      .attr("xlink:href", function(d) {return "#" + d.id})
                      .attr("startOffset", "50%")
                      .text(function(d) {return d.weight;});
      
      var node = svg.selectAll("node")
        .data(nodes)
        .enter()
        .append("g")
          .attr("transform", function(d) {
            return "translate(" + d.x + ", " + d.y + ")";});
      
      var circle = node.append("circle")
          .attr("r", nodeSize)
          .attr("class", "node");
      
      var text = node.append("text")
          .attr("style", "text-anchor: middle; alignment-baseline: middle;")
          .attr("dx", 0)
          .attr("dy", 0)
          .attr("fill", "white")
          .text("bias");
      
      
    </script>
  

  
</body>
</html>
